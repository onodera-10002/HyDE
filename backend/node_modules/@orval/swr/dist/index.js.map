{"version":3,"file":"index.js","names":["AXIOS_DEPENDENCIES: GeneratorDependency[]","OutputHttpClient","getSwrHeader: ClientHeaderBuilder","PARAMS_SERIALIZER_DEPENDENCIES: GeneratorDependency[]","SWR_DEPENDENCIES: GeneratorDependency[]","SWR_INFINITE_DEPENDENCIES: GeneratorDependency[]","SWR_MUTATION_DEPENDENCIES: GeneratorDependency[]","getSwrDependencies: ClientDependenciesBuilder","OutputHttpClient","Verbs","GetterPropType","swrKeyProperties","queryKeyProps","generateSwrHeader: ClientHeaderBuilder","generateSwr: ClientBuilder","swrClientBuilder: ClientGeneratorsBuilder"],"sources":["../src/client.ts","../src/index.ts"],"sourcesContent":["import {\n  ClientHeaderBuilder,\n  generateFormDataAndUrlEncodedFunction,\n  generateMutatorConfig,\n  generateMutatorRequestOptions,\n  generateOptions,\n  GeneratorDependency,\n  GeneratorMutator,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  GetterResponse,\n  isSyntheticDefaultImportsAllow,\n  OutputHttpClient,\n  toObjectString,\n} from '@orval/core';\nimport {\n  fetchResponseTypeName,\n  generateFetchHeader,\n  generateRequestFunction as generateFetchRequestFunction,\n} from '@orval/fetch';\n\nexport const AXIOS_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'axios',\n        default: true,\n        values: true,\n        syntheticDefaultImport: true,\n      },\n      { name: 'AxiosRequestConfig' },\n      { name: 'AxiosResponse' },\n      { name: 'AxiosError' },\n    ],\n    dependency: 'axios',\n  },\n];\n\nexport const generateSwrRequestFunction = (\n  verbOptions: GeneratorVerbOptions,\n  options: GeneratorOptions,\n) => {\n  return options.context.output.httpClient === OutputHttpClient.AXIOS\n    ? generateAxiosRequestFunction(verbOptions, options)\n    : generateFetchRequestFunction(verbOptions, options);\n};\n\nconst generateAxiosRequestFunction = (\n  {\n    headers,\n    queryParams,\n    operationName,\n    response,\n    mutator,\n    body,\n    props,\n    verb,\n    formData,\n    formUrlEncoded,\n    override,\n    paramsSerializer,\n  }: GeneratorVerbOptions,\n  { route, context }: GeneratorOptions,\n) => {\n  const isRequestOptions = override?.requestOptions !== false;\n  const isFormData = !override?.formData.disabled;\n  const isFormUrlEncoded = override?.formUrlEncoded !== false;\n  const isExactOptionalPropertyTypes =\n    !!context.output.tsconfig?.compilerOptions?.exactOptionalPropertyTypes;\n  const isSyntheticDefaultImportsAllowed = isSyntheticDefaultImportsAllow(\n    context.output.tsconfig,\n  );\n\n  const bodyForm = generateFormDataAndUrlEncodedFunction({\n    formData,\n    formUrlEncoded,\n    body,\n    isFormData,\n    isFormUrlEncoded,\n  });\n\n  if (mutator) {\n    const mutatorConfig = generateMutatorConfig({\n      route,\n      body,\n      headers,\n      queryParams,\n      response,\n      verb,\n      isFormData,\n      isFormUrlEncoded,\n      hasSignal: false,\n      isExactOptionalPropertyTypes,\n    });\n\n    const propsImplementation =\n      mutator?.bodyTypeName && body.definition\n        ? toObjectString(props, 'implementation').replace(\n            new RegExp(`(\\\\w*):\\\\s?${body.definition}`),\n            `$1: ${mutator.bodyTypeName}<${body.definition}>`,\n          )\n        : toObjectString(props, 'implementation');\n\n    const requestOptions = isRequestOptions\n      ? generateMutatorRequestOptions(\n          override?.requestOptions,\n          mutator.hasSecondArg,\n        )\n      : '';\n\n    const requestImplementation = `export const ${operationName} = (\\n    ${propsImplementation}\\n ${\n      isRequestOptions && mutator.hasSecondArg\n        ? `options${context.output.optionsParamRequired ? '' : '?'}: SecondParameter<typeof ${mutator.name}>`\n        : ''\n    }) => {${bodyForm}\n    return ${mutator.name}<${response.definition.success || 'unknown'}>(\n    ${mutatorConfig},\n    ${requestOptions});\n  }\n`;\n\n    return requestImplementation;\n  }\n\n  const options = generateOptions({\n    route,\n    body,\n    headers,\n    queryParams,\n    response,\n    verb,\n    requestOptions: override?.requestOptions,\n    isFormData,\n    isFormUrlEncoded,\n    paramsSerializer,\n    paramsSerializerOptions: override?.paramsSerializerOptions,\n    isExactOptionalPropertyTypes,\n    hasSignal: false,\n  });\n\n  return `export const ${operationName} = (\\n    ${toObjectString(\n    props,\n    'implementation',\n  )} ${\n    isRequestOptions ? `options?: AxiosRequestConfig\\n` : ''\n  } ): Promise<AxiosResponse<${\n    response.definition.success || 'unknown'\n  }>> => {${bodyForm}\n    return axios${\n      isSyntheticDefaultImportsAllowed ? '' : '.default'\n    }.${verb}(${options});\n  }\n`;\n};\n\nexport const getSwrRequestOptions = (\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (!mutator) {\n    return httpClient === OutputHttpClient.AXIOS\n      ? 'axios?: AxiosRequestConfig'\n      : 'fetch?: RequestInit';\n  } else if (mutator?.hasSecondArg) {\n    return `request?: SecondParameter<typeof ${mutator.name}>`;\n  } else {\n    return '';\n  }\n};\n\nexport const getSwrErrorType = (\n  response: GetterResponse,\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (mutator) {\n    return mutator.hasErrorType\n      ? `ErrorType<${response.definition.errors || 'unknown'}>`\n      : response.definition.errors || 'unknown';\n  } else {\n    const errorType =\n      httpClient === OutputHttpClient.AXIOS ? 'AxiosError' : 'Promise';\n\n    return `${errorType}<${response.definition.errors || 'unknown'}>`;\n  }\n};\n\nexport const getSwrRequestSecondArg = (\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (!mutator) {\n    return httpClient === OutputHttpClient.AXIOS\n      ? 'axios: axiosOptions'\n      : 'fetch: fetchOptions';\n  } else if (mutator?.hasSecondArg) {\n    return 'request: requestOptions';\n  } else {\n    return '';\n  }\n};\n\nexport const getHttpRequestSecondArg = (\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (!mutator) {\n    return httpClient === OutputHttpClient.AXIOS\n      ? `axiosOptions`\n      : `fetchOptions`;\n  } else if (mutator?.hasSecondArg) {\n    return 'requestOptions';\n  } else {\n    return '';\n  }\n};\n\nexport const getSwrMutationFetcherOptionType = (\n  httpClient: OutputHttpClient,\n  mutator?: GeneratorMutator,\n) => {\n  if (!mutator) {\n    return httpClient === OutputHttpClient.AXIOS\n      ? 'AxiosRequestConfig'\n      : 'RequestInit';\n  } else if (mutator.hasSecondArg) {\n    return `SecondParameter<typeof ${mutator.name}>`;\n  } else {\n    return '';\n  }\n};\n\nexport const getSwrMutationFetcherType = (\n  response: GetterResponse,\n  httpClient: OutputHttpClient,\n  includeHttpResponseReturnType: boolean | undefined,\n  operationName: string,\n  mutator?: GeneratorMutator,\n) => {\n  if (httpClient === OutputHttpClient.FETCH) {\n    const responseType = fetchResponseTypeName(\n      includeHttpResponseReturnType,\n      response.definition.success,\n      operationName,\n    );\n\n    return `Promise<${responseType}>`;\n  } else if (mutator) {\n    return `Promise<${response.definition.success || 'unknown'}>`;\n  } else {\n    return `Promise<AxiosResponse<${response.definition.success || 'unknown'}>>`;\n  }\n};\n\nexport const getSwrHeader: ClientHeaderBuilder = (params) => {\n  return params.output.httpClient === OutputHttpClient.FETCH\n    ? generateFetchHeader(params)\n    : '';\n};\n","import {\n  camel,\n  ClientBuilder,\n  ClientDependenciesBuilder,\n  ClientGeneratorsBuilder,\n  ClientHeaderBuilder,\n  generateVerbImports,\n  GeneratorDependency,\n  GeneratorMutator,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  GetterParams,\n  GetterProp,\n  GetterProps,\n  GetterPropType,\n  GetterResponse,\n  pascal,\n  stringify,\n  toObjectString,\n  Verbs,\n  jsDoc,\n  SwrOptions,\n  OutputHttpClient,\n} from '@orval/core';\nimport {\n  AXIOS_DEPENDENCIES,\n  generateSwrRequestFunction,\n  getSwrRequestOptions,\n  getSwrErrorType,\n  getSwrRequestSecondArg,\n  getHttpRequestSecondArg,\n  getSwrMutationFetcherOptionType,\n  getSwrHeader,\n  getSwrMutationFetcherType,\n} from './client';\n\nconst PARAMS_SERIALIZER_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      {\n        name: 'qs',\n        default: true,\n        values: true,\n        syntheticDefaultImport: true,\n      },\n    ],\n    dependency: 'qs',\n  },\n];\n\nconst SWR_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useSwr', values: true, default: true },\n      { name: 'SWRConfiguration' },\n      { name: 'Key' },\n      { name: 'Arguments' },\n    ],\n    dependency: 'swr',\n  },\n];\n\nconst SWR_INFINITE_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useSWRInfinite', values: true, default: true },\n      { name: 'SWRInfiniteConfiguration' },\n      { name: 'SWRInfiniteKeyLoader' },\n    ],\n    dependency: 'swr/infinite',\n  },\n];\n\nconst SWR_MUTATION_DEPENDENCIES: GeneratorDependency[] = [\n  {\n    exports: [\n      { name: 'useSWRMutation', values: true, default: true },\n      { name: 'SWRMutationConfiguration' },\n      { name: 'SWRMutationKey' },\n    ],\n    dependency: 'swr/mutation',\n  },\n];\n\nexport const getSwrDependencies: ClientDependenciesBuilder = (\n  hasGlobalMutator: boolean,\n  hasParamsSerializerOptions: boolean,\n  _packageJson,\n  httpClient?: OutputHttpClient,\n) => [\n  ...(!hasGlobalMutator && httpClient === OutputHttpClient.AXIOS\n    ? AXIOS_DEPENDENCIES\n    : []),\n  ...(hasParamsSerializerOptions ? PARAMS_SERIALIZER_DEPENDENCIES : []),\n  ...SWR_DEPENDENCIES,\n  ...SWR_INFINITE_DEPENDENCIES,\n  ...SWR_MUTATION_DEPENDENCIES,\n];\n\nconst generateSwrArguments = ({\n  operationName,\n  mutator,\n  isRequestOptions,\n  isInfinite,\n  httpClient,\n}: {\n  operationName: string;\n  mutator?: GeneratorMutator;\n  isRequestOptions: boolean;\n  isInfinite: boolean;\n  httpClient: OutputHttpClient;\n}) => {\n  const configType = isInfinite\n    ? 'SWRInfiniteConfiguration'\n    : 'SWRConfiguration';\n  const optionsType = isInfinite\n    ? '{ swrKeyLoader?: SWRInfiniteKeyLoader, enabled?: boolean }'\n    : '{ swrKey?: Key, enabled?: boolean }';\n  const definition = `${configType}<Awaited<ReturnType<typeof ${operationName}>>, TError> & ${optionsType}`;\n\n  if (!isRequestOptions) {\n    return `swrOptions?: ${definition}`;\n  }\n\n  return `options?: { swr?:${definition}, ${getSwrRequestOptions(httpClient, mutator)} }\\n`;\n};\n\nconst generateSwrMutationArguments = ({\n  operationName,\n  isRequestOptions,\n  mutator,\n  swrBodyType,\n  httpClient,\n}: {\n  operationName: string;\n  isRequestOptions: boolean;\n  mutator?: GeneratorMutator;\n  swrBodyType: string;\n  httpClient: OutputHttpClient;\n}) => {\n  const definition = `SWRMutationConfiguration<Awaited<ReturnType<typeof ${operationName}>>, TError, Key, ${swrBodyType}, Awaited<ReturnType<typeof ${operationName}>>> & { swrKey?: string }`;\n\n  if (!isRequestOptions) {\n    return `swrOptions?: ${definition}`;\n  }\n\n  return `options?: { swr?:${definition}, ${getSwrRequestOptions(httpClient, mutator)}}\\n`;\n};\n\nconst generateSwrImplementation = ({\n  operationName,\n  swrKeyFnName,\n  swrKeyLoaderFnName,\n  swrProperties,\n  swrKeyProperties,\n  params,\n  mutator,\n  isRequestOptions,\n  response,\n  swrOptions,\n  props,\n  doc,\n  httpClient,\n  pathOnlyParams,\n  headerOnlyParams,\n  hasQueryParams,\n  queryParamType,\n}: {\n  isRequestOptions: boolean;\n  operationName: string;\n  swrKeyFnName: string;\n  swrKeyLoaderFnName: string;\n  swrProperties: string;\n  swrKeyProperties: string;\n  params: GetterParams;\n  props: GetterProps;\n  response: GetterResponse;\n  mutator?: GeneratorMutator;\n  swrOptions: SwrOptions;\n  doc?: string;\n  httpClient: OutputHttpClient;\n  pathOnlyParams: string;\n  headerOnlyParams: string;\n  hasQueryParams: boolean;\n  queryParamType: string;\n}) => {\n  const swrProps = toObjectString(props, 'implementation');\n\n  const hasParamReservedWord = props.some(\n    (prop: GetterProp) => prop.name === 'query',\n  );\n  const queryResultVarName = hasParamReservedWord ? '_query' : 'query';\n\n  const httpFunctionProps = swrProperties;\n\n  const enabledImplementation = `const isEnabled = swrOptions?.enabled !== false${\n    params.length\n      ? ` && !!(${params.map(({ name }) => name).join(' && ')})`\n      : ''\n  }`;\n  const swrKeyImplementation = `const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? ${swrKeyFnName}(${swrKeyProperties}) : null);`;\n  const swrKeyLoaderImplementation = `const swrKeyLoader = swrOptions?.swrKeyLoader ?? (isEnabled ? ${swrKeyLoaderFnName}(${swrKeyProperties}) : () => null);`;\n\n  const errorType = getSwrErrorType(response, httpClient, mutator);\n  const swrRequestSecondArg = getSwrRequestSecondArg(httpClient, mutator);\n  const httpRequestSecondArg = getHttpRequestSecondArg(httpClient, mutator);\n\n  const useSWRInfiniteImplementation = swrOptions.useInfinite\n    ? `\nexport type ${pascal(\n        operationName,\n      )}InfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof ${operationName}>>>\nexport type ${pascal(operationName)}InfiniteError = ${errorType}\n\n${doc}export const ${camel(\n        `use-${operationName}-infinite`,\n      )} = <TError = ${errorType}>(\n  ${swrProps} ${generateSwrArguments({\n    operationName,\n    mutator,\n    isRequestOptions,\n    isInfinite: true,\n    httpClient,\n  })}) => {\n  ${\n    isRequestOptions\n      ? `const {swr: swrOptions${swrRequestSecondArg ? `, ${swrRequestSecondArg}` : ''}} = options ?? {}`\n      : ''\n  }\n\n  ${enabledImplementation}\n  ${swrKeyLoaderImplementation}\n  const swrFn = ${\n    hasQueryParams\n      ? `([_url, pageParams]: [string, ${queryParamType} & { page: number }]) => ${operationName}(${pathOnlyParams}${pathOnlyParams ? ', ' : ''}pageParams${headerOnlyParams ? ', ' + headerOnlyParams : ''}${httpRequestSecondArg ? ', ' + httpRequestSecondArg : ''})`\n      : `([_url]: [string]) => ${operationName}(${pathOnlyParams}${headerOnlyParams ? (pathOnlyParams ? ', ' : '') + headerOnlyParams : ''}${httpRequestSecondArg ? (pathOnlyParams || headerOnlyParams ? ', ' : '') + httpRequestSecondArg : ''})`\n  }\n\n  const ${queryResultVarName} = useSWRInfinite<Awaited<ReturnType<typeof swrFn>>, TError>(swrKeyLoader, swrFn, ${\n    swrOptions.swrInfiniteOptions\n      ? `{\n    ${stringify(swrOptions.swrInfiniteOptions)?.slice(1, -1)}\n    ...swrOptions\n  }`\n      : 'swrOptions'\n  })\n\n  return {\n    swrKeyLoader,\n    ...${queryResultVarName}\n  }\n}\\n`\n    : '';\n\n  const useSwrImplementation = `\nexport type ${pascal(\n    operationName,\n  )}QueryResult = NonNullable<Awaited<ReturnType<typeof ${operationName}>>>\nexport type ${pascal(operationName)}QueryError = ${errorType}\n\n${doc}export const ${camel(`use-${operationName}`)} = <TError = ${errorType}>(\n  ${swrProps} ${generateSwrArguments({\n    operationName,\n    mutator,\n    isRequestOptions,\n    isInfinite: false,\n    httpClient,\n  })}) => {\n  ${\n    isRequestOptions\n      ? `const {swr: swrOptions${swrRequestSecondArg ? `, ${swrRequestSecondArg}` : ''}} = options ?? {}`\n      : ''\n  }\n\n  ${enabledImplementation}\n  ${swrKeyImplementation}\n  const swrFn = () => ${operationName}(${httpFunctionProps}${\n    httpFunctionProps && httpRequestSecondArg ? ', ' : ''\n  }${httpRequestSecondArg})\n\n  const ${queryResultVarName} = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, ${\n    swrOptions.swrOptions\n      ? `{\n    ${stringify(swrOptions.swrOptions)?.slice(1, -1)}\n    ...swrOptions\n  }`\n      : 'swrOptions'\n  })\n\n  return {\n    swrKey,\n    ...${queryResultVarName}\n  }\n}\\n`;\n\n  return useSWRInfiniteImplementation + useSwrImplementation;\n};\n\nconst generateSwrMutationImplementation = ({\n  isRequestOptions,\n  operationName,\n  swrKeyFnName,\n  swrMutationFetcherName,\n  swrKeyProperties,\n  swrMutationFetcherProperties,\n  swrProps,\n  props,\n  response,\n  mutator,\n  swrOptions,\n  doc,\n  swrBodyType,\n  httpClient,\n  verb,\n}: {\n  isRequestOptions: boolean;\n  operationName: string;\n  swrKeyFnName: string;\n  swrMutationFetcherName: string;\n  swrKeyProperties: string;\n  swrMutationFetcherProperties: string;\n  swrProps: string;\n  props: GetterProps;\n  response: GetterResponse;\n  mutator?: GeneratorMutator;\n  swrOptions: SwrOptions;\n  doc?: string;\n  swrBodyType: string;\n  httpClient: OutputHttpClient;\n  verb?: Verbs;\n}) => {\n  const hasParamReservedWord = props.some(\n    (prop: GetterProp) => prop.name === 'query',\n  );\n  const queryResultVarName = hasParamReservedWord ? '_query' : 'query';\n\n  const swrKeyImplementation = `const swrKey = swrOptions?.swrKey ?? ${swrKeyFnName}(${swrKeyProperties});`;\n\n  const errorType = getSwrErrorType(response, httpClient, mutator);\n  const swrRequestSecondArg = getSwrRequestSecondArg(httpClient, mutator);\n  const httpRequestSecondArg = getHttpRequestSecondArg(httpClient, mutator);\n\n  const useSwrImplementation = `\nexport type ${pascal(\n    operationName,\n  )}MutationResult = NonNullable<Awaited<ReturnType<typeof ${operationName}>>>\nexport type ${pascal(operationName)}MutationError = ${errorType}\n\n${doc}export const ${camel(`use-${operationName}${verb === Verbs.GET ? '-mutation' : ''}`)} = <TError = ${errorType}>(\n  ${swrProps} ${generateSwrMutationArguments({\n    operationName,\n    isRequestOptions,\n    mutator,\n    swrBodyType,\n    httpClient,\n  })}) => {\n\n  ${isRequestOptions ? `const {swr: swrOptions${swrRequestSecondArg ? `, ${swrRequestSecondArg}` : ''}} = options ?? {}` : ''}\n\n  ${swrKeyImplementation}\n  const swrFn = ${swrMutationFetcherName}(${swrMutationFetcherProperties}${\n    swrMutationFetcherProperties && httpRequestSecondArg ? ', ' : ''\n  }${httpRequestSecondArg});\n\n  const ${queryResultVarName} = useSWRMutation(swrKey, swrFn, ${\n    swrOptions.swrMutationOptions\n      ? `{\n    ${stringify(swrOptions.swrMutationOptions)?.slice(1, -1)}\n    ...swrOptions\n  }`\n      : 'swrOptions'\n  })\n\n  return {\n    swrKey,\n    ...${queryResultVarName}\n  }\n}\\n`;\n\n  return useSwrImplementation;\n};\n\nconst generateSwrHook = (\n  {\n    queryParams,\n    operationName,\n    body,\n    props,\n    verb,\n    params,\n    override,\n    mutator,\n    response,\n    summary,\n    deprecated,\n  }: GeneratorVerbOptions,\n  { route, context }: GeneratorOptions,\n) => {\n  const isRequestOptions = override?.requestOptions !== false;\n  const httpClient = context.output.httpClient;\n  const doc = jsDoc({ summary, deprecated });\n\n  const queryKeyProps = toObjectString(\n    props.filter(\n      (prop) =>\n        prop.type === GetterPropType.PARAM ||\n        prop.type === GetterPropType.NAMED_PATH_PARAMS ||\n        prop.type === GetterPropType.QUERY_PARAM,\n    ),\n    'implementation',\n  );\n\n  const swrProps = toObjectString(\n    props.filter(\n      (prop) =>\n        prop.type === GetterPropType.PARAM ||\n        prop.type === GetterPropType.QUERY_PARAM ||\n        prop.type === GetterPropType.NAMED_PATH_PARAMS ||\n        prop.type === GetterPropType.HEADER,\n    ),\n    'implementation',\n  );\n\n  const swrMutationFetcherProperties = props\n    .filter(\n      (prop) =>\n        prop.type === GetterPropType.PARAM ||\n        prop.type === GetterPropType.QUERY_PARAM ||\n        prop.type === GetterPropType.NAMED_PATH_PARAMS ||\n        prop.type === GetterPropType.HEADER,\n    )\n    .map((param) => {\n      if (param.type === GetterPropType.NAMED_PATH_PARAMS) {\n        return param.destructured;\n      } else {\n        return param.name;\n      }\n    })\n    .join(',');\n\n  const swrKeyProperties = props\n    .filter(\n      (prop) =>\n        prop.type === GetterPropType.PARAM ||\n        prop.type === GetterPropType.NAMED_PATH_PARAMS ||\n        prop.type === GetterPropType.QUERY_PARAM,\n    )\n    .map((prop) => {\n      if (prop.type === GetterPropType.NAMED_PATH_PARAMS) {\n        return prop.destructured;\n      } else {\n        return prop.name;\n      }\n    })\n    .join(',');\n\n  const swrMutationFetcherName = camel(`get-${operationName}-mutation-fetcher`);\n\n  if (verb === Verbs.GET) {\n    const swrKeyProperties = props\n      .filter((prop) => prop.type !== GetterPropType.HEADER)\n      .map((param) => {\n        if (param.type === GetterPropType.NAMED_PATH_PARAMS)\n          return param.destructured;\n        return param.type === GetterPropType.BODY\n          ? body.implementation\n          : param.name;\n      })\n      .join(',');\n\n    const swrProperties = props\n      .map((param) => {\n        if (param.type === GetterPropType.NAMED_PATH_PARAMS)\n          return param.destructured;\n        return param.type === GetterPropType.BODY\n          ? body.implementation\n          : param.name;\n      })\n      .join(',');\n\n    // For useSWRInfinite: separate path params from query params\n    const pathOnlyParams = props\n      .filter(\n        (prop) =>\n          prop.type === GetterPropType.PARAM ||\n          prop.type === GetterPropType.NAMED_PATH_PARAMS,\n      )\n      .map((param) => {\n        return param.type === GetterPropType.NAMED_PATH_PARAMS\n          ? param.destructured\n          : param.name;\n      })\n      .join(',');\n\n    const headerOnlyParams = props\n      .filter((prop) => prop.type === GetterPropType.HEADER)\n      .map((param) => param.name)\n      .join(',');\n\n    const hasQueryParams = props.some(\n      (prop) => prop.type === GetterPropType.QUERY_PARAM,\n    );\n\n    // Extract just the type name from definition (e.g., \"params: ListPetsParams\" -> \"ListPetsParams\")\n    const queryParamType =\n      props\n        .find((prop) => prop.type === GetterPropType.QUERY_PARAM)\n        ?.definition.split(': ')[1] || 'never';\n\n    const queryKeyProps = toObjectString(\n      props.filter((prop) => prop.type !== GetterPropType.HEADER),\n      'implementation',\n    );\n\n    const swrKeyFnName = camel(`get-${operationName}-key`);\n    const swrKeyFn = `\nexport const ${swrKeyFnName} = (${queryKeyProps}) => [\\`${route}\\`${\n      queryParams ? ', ...(params ? [params]: [])' : ''\n    }] as const;\n`;\n\n    const swrKeyLoaderFnName = camel(\n      `get-${operationName}-infinite-key-loader`,\n    );\n    const swrKeyLoader = override.swr.useInfinite\n      ? `export const ${swrKeyLoaderFnName} = (${queryKeyProps}) => {\n  return (page: number, previousPageData?: Awaited<ReturnType<typeof ${operationName}>>) => {\n    if (previousPageData && !previousPageData.data) return null\n\n    return [\\`${route}\\`${queryParams ? ', ...(params ? [{...params,page}]: [{page}])' : ''}${\n      body.implementation ? `, ${body.implementation}` : ''\n    }] as const;\n  }\n}\\n`\n      : '';\n\n    const swrImplementation = generateSwrImplementation({\n      operationName,\n      swrKeyFnName,\n      swrKeyLoaderFnName,\n      swrProperties,\n      swrKeyProperties,\n      params,\n      props,\n      mutator,\n      isRequestOptions,\n      response,\n      swrOptions: override.swr,\n      doc,\n      httpClient,\n      pathOnlyParams,\n      headerOnlyParams,\n      hasQueryParams,\n      queryParamType,\n    });\n\n    if (!override.swr.useSWRMutationForGet) {\n      return swrKeyFn + swrKeyLoader + swrImplementation;\n    }\n\n    // For OutputClient.SWR_GET_MUTATION, generate both useSWR and useSWRMutation\n    const httpFnPropertiesForGetWithoutHeaders = props\n      .filter((prop) => prop.type !== GetterPropType.HEADER)\n      .map((prop) => {\n        if (prop.type === GetterPropType.NAMED_PATH_PARAMS) {\n          return prop.destructured;\n        } else {\n          return prop.name;\n        }\n      })\n      .join(', ');\n\n    const headerParamsForGet = props\n      .filter((prop) => prop.type === GetterPropType.HEADER)\n      .map((param) => param.name)\n      .join(', ');\n\n    const httpFnPropertiesForGet = [\n      httpFnPropertiesForGetWithoutHeaders,\n      headerParamsForGet,\n    ]\n      .filter(Boolean)\n      .join(', ');\n\n    const swrMutationFetcherType = getSwrMutationFetcherType(\n      response,\n      httpClient,\n      override.fetch?.includeHttpResponseReturnType,\n      operationName,\n      mutator,\n    );\n    const swrMutationFetcherOptionType = getSwrMutationFetcherOptionType(\n      httpClient,\n      mutator,\n    );\n\n    const swrMutationFetcherOptions =\n      isRequestOptions && swrMutationFetcherOptionType\n        ? `options${context.output.optionsParamRequired ? '' : '?'}: ${swrMutationFetcherOptionType}`\n        : '';\n\n    const swrMutationFetcherFn = `\nexport const ${swrMutationFetcherName} = (${queryKeyProps} ${swrMutationFetcherOptions}) => {\n  return (_: Key, __: { arg?: never }): ${swrMutationFetcherType} => {\n    return ${operationName}(${httpFnPropertiesForGet}${\n      swrMutationFetcherOptions.length\n        ? (httpFnPropertiesForGet.length ? ', ' : '') + 'options'\n        : ''\n    });\n  }\n}\n`;\n\n    const swrMutationImplementation = generateSwrMutationImplementation({\n      operationName,\n      swrKeyFnName,\n      swrMutationFetcherName,\n      swrKeyProperties,\n      swrMutationFetcherProperties,\n      swrProps,\n      props,\n      isRequestOptions,\n      response,\n      mutator,\n      swrOptions: override.swr,\n      doc,\n      swrBodyType: 'never',\n      httpClient,\n      verb: Verbs.GET,\n    });\n\n    return (\n      swrKeyFn +\n      swrKeyLoader +\n      swrImplementation +\n      swrMutationFetcherFn +\n      swrMutationImplementation\n    );\n  } else {\n    const httpFnPropertiesWithoutHeaders = props\n      .filter((prop) => prop.type !== GetterPropType.HEADER)\n      .map((prop) => {\n        if (prop.type === GetterPropType.NAMED_PATH_PARAMS) {\n          return prop.destructured;\n        } else if (prop.type === GetterPropType.BODY) {\n          return `arg`;\n        } else {\n          return prop.name;\n        }\n      })\n      .join(', ');\n\n    const headerParams = props\n      .filter((prop) => prop.type === GetterPropType.HEADER)\n      .map((param) => param.name)\n      .join(', ');\n\n    const httpFnProperties = [httpFnPropertiesWithoutHeaders, headerParams]\n      .filter(Boolean)\n      .join(', ');\n\n    const swrKeyFnName = camel(`get-${operationName}-mutation-key`);\n    const swrMutationKeyFn = `export const ${swrKeyFnName} = (${queryKeyProps}) => [\\`${route}\\`${\n      queryParams ? ', ...(params ? [params]: [])' : ''\n    }] as const;\n`;\n\n    const swrMutationFetcherType = getSwrMutationFetcherType(\n      response,\n      httpClient,\n      override.fetch?.includeHttpResponseReturnType,\n      operationName,\n      mutator,\n    );\n    const swrMutationFetcherOptionType = getSwrMutationFetcherOptionType(\n      httpClient,\n      mutator,\n    );\n\n    const swrMutationFetcherOptions =\n      isRequestOptions && swrMutationFetcherOptionType\n        ? `options${context.output.optionsParamRequired ? '' : '?'}: ${swrMutationFetcherOptionType}`\n        : '';\n\n    const swrMutationFetcherArg = props.some(\n      (prop) => prop.type === GetterPropType.BODY,\n    )\n      ? '{ arg }'\n      : '__';\n\n    const swrBodyType =\n      props\n        .find((prop) => prop.type === GetterPropType.BODY)\n        ?.implementation.split(': ')[1] ?? 'Arguments';\n\n    const swrMutationFetcherFn = `\nexport const ${swrMutationFetcherName} = (${swrProps} ${swrMutationFetcherOptions}) => {\n  return (_: Key, ${swrMutationFetcherArg}: { arg: ${swrBodyType} }) => {\n    return ${operationName}(${httpFnProperties}${\n      swrMutationFetcherOptions.length\n        ? (httpFnProperties.length ? ', ' : '') + 'options'\n        : ''\n    });\n  }\n}\\n`;\n\n    const swrImplementation = generateSwrMutationImplementation({\n      operationName,\n      swrKeyFnName,\n      swrMutationFetcherName,\n      swrKeyProperties,\n      swrMutationFetcherProperties,\n      swrProps,\n      props,\n      isRequestOptions,\n      response,\n      mutator,\n      swrOptions: override.swr,\n      doc,\n      swrBodyType,\n      httpClient: context.output.httpClient,\n    });\n\n    return swrMutationFetcherFn + swrMutationKeyFn + swrImplementation;\n  }\n};\n\nexport const generateSwrHeader: ClientHeaderBuilder = (params) =>\n  `\n  ${\n    !params.hasAwaitedType\n      ? `type AwaitedInput<T> = PromiseLike<T> | T;\\n\n      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;\\n\\n`\n      : ''\n  }\n  ${\n    params.isRequestOptions && params.isMutator\n      ? `type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];\\n\\n`\n      : ''\n  }\n  ${getSwrHeader(params)}\n`;\n\nexport const generateSwr: ClientBuilder = (verbOptions, options) => {\n  const imports = generateVerbImports(verbOptions);\n  const functionImplementation = generateSwrRequestFunction(\n    verbOptions,\n    options,\n  );\n  const hookImplementation = generateSwrHook(verbOptions, options);\n\n  return {\n    implementation: `${functionImplementation}\\n\\n${hookImplementation}`,\n    imports,\n  };\n};\n\nconst swrClientBuilder: ClientGeneratorsBuilder = {\n  client: generateSwr,\n  header: generateSwrHeader,\n  dependencies: getSwrDependencies,\n};\n\nexport const builder = () => () => swrClientBuilder;\n\nexport default builder;\n"],"mappings":"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"}