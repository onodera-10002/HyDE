{"version":3,"file":"index.js","names":["DEFAULT_FORMAT_MOCK: Record<\n  Required<SchemaObject>['format'],\n  string\n>","imports: GeneratorImport[]","includedProperties: string[]","PropertySortOrder","numberImports: GeneratorImport[]","stringImports: GeneratorImport[]","enumImports: GeneratorImport[]","EnumGeneration","combineImports: GeneratorImport[]","includedProperties: string[]","generalJSTypesWithArray","exports","generateMSWImports: GenerateMockImports","splitMockImplementations: string[]","DEFAULT_MOCK_OPTIONS: GlobalMockOptions","generateMockImports: GenerateMockImports"],"sources":["../src/delay.ts","../src/faker/compatibleV9.ts","../src/faker/constants.ts","../src/faker/getters/object.ts","../src/faker/getters/scalar.ts","../src/faker/resolvers/value.ts","../src/faker/getters/combine.ts","../src/faker/getters/route.ts","../src/msw/mocks.ts","../src/msw/index.ts","../src/index.ts"],"sourcesContent":["import { GlobalMockOptions, NormalizedOverrideOutput } from '@orval/core';\n\nexport const getDelay = (\n  override?: NormalizedOverrideOutput,\n  options?: GlobalMockOptions,\n): GlobalMockOptions['delay'] => {\n  const overrideDelay =\n    override?.mock?.delay === undefined\n      ? options?.delay\n      : override?.mock?.delay;\n  const delayFunctionLazyExecute =\n    override?.mock?.delayFunctionLazyExecute ??\n    options?.delayFunctionLazyExecute;\n  switch (typeof overrideDelay) {\n    case 'function': {\n      return delayFunctionLazyExecute ? overrideDelay : overrideDelay();\n    }\n    case 'number':\n    case 'boolean': {\n      return overrideDelay;\n    }\n    default: {\n      return 1000;\n    }\n  }\n};\n","import { compareVersions, PackageJson } from '@orval/core';\n\nconst getFakerPackageVersion = (packageJson: PackageJson) => {\n  return (\n    packageJson.dependencies?.['@faker-js/faker'] ??\n    packageJson.devDependencies?.['@faker-js/faker'] ??\n    packageJson.peerDependencies?.['@faker-js/faker']\n  );\n};\n\nexport const isFakerVersionV9 = (packageJson: PackageJson) => {\n  const version = getFakerPackageVersion(packageJson);\n\n  if (!version) {\n    return false;\n  }\n\n  const withoutRc = version.split('-')[0];\n\n  return compareVersions(withoutRc, '9.0.0');\n};\n","import { SchemaObject } from 'openapi3-ts/oas30';\n\nexport const DEFAULT_FORMAT_MOCK: Record<\n  Required<SchemaObject>['format'],\n  string\n> = {\n  bic: 'faker.finance.bic()',\n  binary:\n    \"new Blob(faker.helpers.arrayElements(faker.word.words(10).split(' ')))\",\n  city: 'faker.location.city()',\n  country: 'faker.location.country()',\n  date: \"faker.date.past().toISOString().split('T')[0]\",\n  'date-time': \"`${faker.date.past().toISOString().split('.')[0]}Z`\",\n  email: 'faker.internet.email()',\n  firstName: 'faker.person.firstName()',\n  gender: 'faker.person.gender()',\n  iban: 'faker.finance.iban()',\n  ipv4: 'faker.internet.ipv4()',\n  ipv6: 'faker.internet.ipv6()',\n  jobTitle: 'faker.person.jobTitle()',\n  lastName: 'faker.person.lastName()',\n  password: 'faker.internet.password()',\n  phoneNumber: 'faker.phone.number()',\n  streetName: 'faker.location.street()',\n  uri: 'faker.internet.url()',\n  url: 'faker.internet.url()',\n  userName: 'faker.internet.userName()',\n  uuid: 'faker.string.uuid()',\n  zipCode: 'faker.location.zipCode()',\n};\n\n// #980 replace CUID so tests are consistent\nexport const DEFAULT_OBJECT_KEY_MOCK = 'faker.string.alphanumeric(5)';\n","import {\n  type ContextSpecs,\n  type GeneratorImport,\n  getKey,\n  isBoolean,\n  isReference,\n  type MockOptions,\n  pascal,\n  PropertySortOrder,\n} from '@orval/core';\nimport type { ReferenceObject, SchemaObject } from 'openapi3-ts/oas30';\n\nimport type { MockDefinition, MockSchemaObject } from '../../types';\nimport { DEFAULT_OBJECT_KEY_MOCK } from '../constants';\nimport { resolveMockValue } from '../resolvers/value';\nimport { combineSchemasMock } from './combine';\n\nexport const overrideVarName = 'overrideResponse';\n\nexport const getMockObject = ({\n  item,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride = false,\n}: {\n  item: MockSchemaObject;\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  // This is used to add the overrideResponse to the object\n  allowOverride?: boolean;\n}): MockDefinition => {\n  if (isReference(item)) {\n    return resolveMockValue({\n      schema: {\n        ...item,\n        name: item.name,\n        path: item.path ? `${item.path}.${item.name}` : item.name,\n      },\n      mockOptions,\n      operationId,\n      tags,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (item.allOf || item.oneOf || item.anyOf) {\n    const separator = item.allOf ? 'allOf' : item.oneOf ? 'oneOf' : 'anyOf';\n    return combineSchemasMock({\n      item,\n      separator,\n      mockOptions,\n      operationId,\n      tags,\n      combine,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (Array.isArray(item.type)) {\n    return combineSchemasMock({\n      item: {\n        anyOf: item.type.map((type) => ({ type })),\n        name: item.name,\n      },\n      separator: 'anyOf',\n      mockOptions,\n      operationId,\n      tags,\n      combine,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (item.properties) {\n    let value =\n      !combine ||\n      combine?.separator === 'oneOf' ||\n      combine?.separator === 'anyOf'\n        ? '{'\n        : '';\n    const imports: GeneratorImport[] = [];\n    const includedProperties: string[] = [];\n\n    const entries = Object.entries(item.properties);\n    if (context.output.propertySortOrder === PropertySortOrder.ALPHABETICAL) {\n      entries.sort((a, b) => {\n        return a[0].localeCompare(b[0]);\n      });\n    }\n    const properyScalars = entries\n      .map(([key, prop]: [string, ReferenceObject | SchemaObject]) => {\n        if (combine?.includedProperties.includes(key)) {\n          return;\n        }\n\n        const isRequired =\n          mockOptions?.required ||\n          (Array.isArray(item.required) ? item.required : []).includes(key);\n\n        // Check to see if the property is a reference to an existing property\n        // Fixes issue #910\n        if (\n          '$ref' in prop &&\n          existingReferencedProperties.includes(\n            pascal(prop.$ref.split('/').pop()!),\n          )\n        ) {\n          return;\n        }\n\n        const resolvedValue = resolveMockValue({\n          schema: {\n            ...prop,\n            name: key,\n            path: item.path ? `${item.path}.${key}` : `#.${key}`,\n          },\n          mockOptions,\n          operationId,\n          tags,\n          context,\n          imports,\n          existingReferencedProperties,\n          splitMockImplementations,\n        });\n\n        imports.push(...resolvedValue.imports);\n        includedProperties.push(key);\n\n        const keyDefinition = getKey(key);\n        if (!isRequired && !resolvedValue.overrided) {\n          return `${keyDefinition}: faker.helpers.arrayElement([${resolvedValue.value}, undefined])`;\n        }\n\n        return `${keyDefinition}: ${resolvedValue.value}`;\n      })\n      .filter(Boolean);\n\n    if (allowOverride) {\n      properyScalars.push(`...${overrideVarName}`);\n    }\n\n    value += properyScalars.join(', ');\n    value +=\n      !combine ||\n      combine?.separator === 'oneOf' ||\n      combine?.separator === 'anyOf'\n        ? '}'\n        : '';\n\n    return {\n      value,\n      imports,\n      name: item.name,\n      includedProperties,\n    };\n  }\n\n  if (item.additionalProperties) {\n    if (isBoolean(item.additionalProperties)) {\n      return { value: `{}`, imports: [], name: item.name };\n    }\n    if (\n      isReference(item.additionalProperties) &&\n      existingReferencedProperties.includes(\n        item.additionalProperties.$ref.split('/').pop()!,\n      )\n    ) {\n      return { value: `{}`, imports: [], name: item.name };\n    }\n\n    const resolvedValue = resolveMockValue({\n      schema: {\n        ...item.additionalProperties,\n        name: item.name,\n        path: item.path ? `${item.path}.#` : '#',\n      },\n      mockOptions,\n      operationId,\n      tags,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n\n    return {\n      ...resolvedValue,\n      value: `{\n        [${DEFAULT_OBJECT_KEY_MOCK}]: ${resolvedValue.value}\n      }`,\n    };\n  }\n\n  return { value: '{}', imports: [], name: item.name };\n};\n","import {\n  type ContextSpecs,\n  EnumGeneration,\n  escape,\n  type GeneratorImport,\n  isReference,\n  isRootKey,\n  mergeDeep,\n  type MockOptions,\n  pascal,\n} from '@orval/core';\nimport type { SchemaObject as SchemaObject31 } from 'openapi3-ts/oas31';\n\nimport type { MockDefinition, MockSchemaObject } from '../../types';\nimport { isFakerVersionV9 } from '../compatibleV9';\nimport { DEFAULT_FORMAT_MOCK } from '../constants';\nimport {\n  getNullable,\n  resolveMockOverride,\n  resolveMockValue,\n} from '../resolvers';\nimport { getMockObject } from './object';\n\nexport const getMockScalar = ({\n  item,\n  imports,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride = false,\n}: {\n  item: MockSchemaObject;\n  imports: GeneratorImport[];\n  mockOptions?: MockOptions;\n  operationId: string;\n  isRef?: boolean;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  // This is used to add the overrideResponse to the object\n  allowOverride?: boolean;\n}): MockDefinition => {\n  // Add the property to the existing properties to validate on object recursion\n  if (item.isRef) {\n    existingReferencedProperties = [...existingReferencedProperties, item.name];\n  }\n\n  const operationProperty = resolveMockOverride(\n    mockOptions?.operations?.[operationId]?.properties,\n    item,\n  );\n\n  if (operationProperty) {\n    return operationProperty;\n  }\n\n  const overrideTag = Object.entries(mockOptions?.tags ?? {})\n    .sort((a, b) => {\n      return a[0].localeCompare(b[0]);\n    })\n    .reduce(\n      (acc, [tag, options]) =>\n        tags.includes(tag) ? mergeDeep(acc, options) : acc,\n      {} as { properties: Record<string, unknown> },\n    );\n\n  const tagProperty = resolveMockOverride(overrideTag?.properties, item);\n\n  if (tagProperty) {\n    return tagProperty;\n  }\n\n  const property = resolveMockOverride(mockOptions?.properties, item);\n\n  if (property) {\n    return property;\n  }\n\n  if (\n    (context.output.override?.mock?.useExamples || mockOptions?.useExamples) &&\n    item.example !== undefined\n  ) {\n    return {\n      value: JSON.stringify(item.example),\n      imports: [],\n      name: item.name,\n      overrided: true,\n    };\n  }\n\n  const ALL_FORMAT = {\n    ...DEFAULT_FORMAT_MOCK,\n    ...mockOptions?.format,\n  };\n\n  if (item.format && ALL_FORMAT[item.format]) {\n    let value = ALL_FORMAT[item.format] as string;\n\n    const dateFormats = ['date', 'date-time'];\n    if (dateFormats.includes(item.format) && context.output.override.useDates) {\n      value = `new Date(${value})`;\n    }\n\n    return {\n      value: getNullable(value, item.nullable),\n      imports: [],\n      name: item.name,\n      overrided: false,\n    };\n  }\n\n  const type = getItemType(item);\n  const isFakerV9 =\n    !!context.output.packageJson &&\n    isFakerVersionV9(context.output.packageJson);\n\n  switch (type) {\n    case 'number':\n    case 'integer': {\n      const intFunction =\n        context.output.override.useBigInt &&\n        (item.format === 'int64' || item.format === 'uint64')\n          ? 'bigInt'\n          : 'int';\n      let value = getNullable(\n        `faker.number.${intFunction}({min: ${item.minimum ?? mockOptions?.numberMin}, max: ${item.maximum ?? mockOptions?.numberMax}${isFakerV9 && item.multipleOf !== undefined ? `, multipleOf: ${item.multipleOf}` : ''}})`,\n        item.nullable,\n      );\n      if (type === 'number') {\n        value = getNullable(\n          `faker.number.float({min: ${item.minimum ?? mockOptions?.numberMin}, max: ${item.maximum ?? mockOptions?.numberMax}${isFakerV9 && item.multipleOf !== undefined ? `, multipleOf: ${item.multipleOf}` : `, fractionDigits: ${mockOptions?.fractionDigits}`}})`,\n          item.nullable,\n        );\n      }\n      const numberImports: GeneratorImport[] = [];\n\n      if (item.enum) {\n        value = getEnum(\n          item,\n          numberImports,\n          context,\n          existingReferencedProperties,\n          'number',\n        );\n      } else if ('const' in item) {\n        value = '' + (item as SchemaObject31).const;\n      }\n\n      return {\n        value,\n        enums: item.enum,\n        imports: numberImports,\n        name: item.name,\n      };\n    }\n\n    case 'boolean': {\n      let value = 'faker.datatype.boolean()';\n      if ('const' in item) {\n        value = '' + (item as SchemaObject31).const;\n      }\n      return {\n        value,\n        imports: [],\n        name: item.name,\n      };\n    }\n\n    case 'array': {\n      if (!item.items) {\n        return { value: '[]', imports: [], name: item.name };\n      }\n\n      if (\n        '$ref' in item.items &&\n        existingReferencedProperties.includes(\n          pascal(item.items.$ref.split('/').pop()!),\n        )\n      ) {\n        return { value: '[]', imports: [], name: item.name };\n      }\n\n      const {\n        value,\n        enums,\n        imports: resolvedImports,\n      } = resolveMockValue({\n        schema: {\n          ...item.items,\n          name: item.name,\n          path: item.path ? `${item.path}.[]` : '#.[]',\n        },\n        combine,\n        mockOptions,\n        operationId,\n        tags,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n      });\n\n      if (enums) {\n        return {\n          value,\n          imports: resolvedImports,\n          name: item.name,\n        };\n      }\n\n      let mapValue = value;\n\n      if (\n        combine &&\n        !value.startsWith('faker') &&\n        !value.startsWith('{') &&\n        !value.startsWith('Array.from')\n      ) {\n        mapValue = `{${value}}`;\n      }\n\n      return {\n        value:\n          `Array.from({ length: faker.number.int({ ` +\n          `min: ${item.minItems ?? mockOptions?.arrayMin}, ` +\n          `max: ${item.maxItems ?? mockOptions?.arrayMax} }) ` +\n          `}, (_, i) => i + 1).map(() => (${mapValue}))`,\n        imports: resolvedImports,\n        name: item.name,\n      };\n    }\n\n    case 'string': {\n      const length = `{length: {min: ${item.minLength ?? mockOptions?.stringMin}, max: ${item.maxLength ?? mockOptions?.stringMax}}}`;\n      let value = `faker.string.alpha(${length})`;\n      const stringImports: GeneratorImport[] = [];\n\n      if (item.enum) {\n        value = getEnum(\n          item,\n          stringImports,\n          context,\n          existingReferencedProperties,\n          'string',\n        );\n      } else if (item.pattern) {\n        value = `faker.helpers.fromRegExp('${item.pattern}')`;\n      } else if ('const' in item) {\n        value = `'${(item as SchemaObject31).const}'`;\n      }\n\n      return {\n        value: getNullable(value, item.nullable),\n        enums: item.enum,\n        name: item.name,\n        imports: stringImports,\n      };\n    }\n\n    case 'null': {\n      return {\n        value: 'null',\n        imports: [],\n        name: item.name,\n      };\n    }\n\n    default: {\n      if (item.enum) {\n        const enumImports: GeneratorImport[] = [];\n        const value = getEnum(\n          item,\n          enumImports,\n          context,\n          existingReferencedProperties,\n        );\n\n        return {\n          value,\n          enums: item.enum,\n          imports: enumImports,\n          name: item.name,\n        };\n      }\n\n      return getMockObject({\n        item,\n        mockOptions,\n        operationId,\n        tags,\n        combine: combine\n          ? {\n              separator: combine.separator,\n              includedProperties: [],\n            }\n          : undefined,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n        allowOverride,\n      });\n    }\n  }\n};\n\nfunction getItemType(item: MockSchemaObject) {\n  if (item.type) return item.type;\n  if (!item.enum) return;\n\n  const uniqTypes = new Set(item.enum.map((value) => typeof value));\n  if (uniqTypes.size > 1) return;\n\n  const type = [...uniqTypes.values()].at(0);\n  if (!type) return;\n  return ['string', 'number'].includes(type) ? type : undefined;\n}\n\nconst getEnum = (\n  item: MockSchemaObject,\n  imports: GeneratorImport[],\n  context: ContextSpecs,\n  existingReferencedProperties: string[],\n  type?: 'string' | 'number',\n) => {\n  if (!item.enum) return '';\n  const joindEnumValues = item.enum\n    .filter((e) => e !== null)\n    .map((e) =>\n      type === 'string' || (type === undefined && typeof e === 'string')\n        ? `'${escape(e)}'`\n        : e,\n    )\n    .join(',');\n\n  let enumValue = `[${joindEnumValues}]`;\n  if (context.output.override.enumGenerationType === EnumGeneration.ENUM) {\n    if (item.isRef || existingReferencedProperties.length === 0) {\n      enumValue += ` as ${item.name}${item.name.endsWith('[]') ? '' : '[]'}`;\n      imports.push({\n        name: item.name,\n        ...(isRootKey(context.specKey, context.target)\n          ? {}\n          : { specKey: context.specKey }),\n      });\n    } else {\n      enumValue += ` as ${existingReferencedProperties[existingReferencedProperties.length - 1]}['${item.name}']`;\n      if (!item.path?.endsWith('[]')) enumValue += '[]';\n      imports.push({\n        name: existingReferencedProperties[\n          existingReferencedProperties.length - 1\n        ],\n        ...(isRootKey(context.specKey, context.target)\n          ? {}\n          : { specKey: context.specKey }),\n      });\n    }\n  } else {\n    enumValue += ' as const';\n  }\n\n  // But if the value is a reference, we can use the object directly via the imports and using Object.values.\n  if (item.isRef && type === 'string') {\n    enumValue = `Object.values(${item.name})`;\n    imports.push({\n      name: item.name,\n      values: true,\n      ...(isRootKey(context.specKey, context.target)\n        ? {}\n        : { specKey: context.specKey }),\n    });\n  }\n\n  return item.path?.endsWith('[]')\n    ? `faker.helpers.arrayElements(${enumValue})`\n    : `faker.helpers.arrayElement(${enumValue})`;\n};\n","import {\n  type ContextSpecs,\n  type GeneratorImport,\n  getRefInfo,\n  isReference,\n  isRootKey,\n  type MockOptions,\n  pascal,\n} from '@orval/core';\nimport type { SchemaObject } from 'openapi3-ts/oas30';\n\nimport type { MockDefinition, MockSchemaObject } from '../../types';\nimport { overrideVarName } from '../getters';\nimport { getMockScalar } from '../getters/scalar';\n\nconst isRegex = (key: string) => key.startsWith('/') && key.endsWith('/');\n\nexport const resolveMockOverride = (\n  properties: Record<string, unknown> | undefined = {},\n  item: SchemaObject & { name: string; path?: string },\n) => {\n  const path = item.path ? item.path : `#.${item.name}`;\n  const property = Object.entries(properties).find(([key]) => {\n    if (isRegex(key)) {\n      const regex = new RegExp(key.slice(1, -1));\n      if (regex.test(item.name) || regex.test(path)) {\n        return true;\n      }\n    }\n\n    if (`#.${key}` === path) {\n      return true;\n    }\n\n    return false;\n  });\n\n  if (!property) {\n    return;\n  }\n\n  return {\n    value: getNullable(property[1] as string, item.nullable),\n    imports: [],\n    name: item.name,\n    overrided: true,\n  };\n};\n\nexport const getNullable = (value: string, nullable?: boolean) =>\n  nullable ? `faker.helpers.arrayElement([${value}, null])` : value;\n\nexport const resolveMockValue = ({\n  schema,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride,\n}: {\n  schema: MockSchemaObject;\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  allowOverride?: boolean;\n}): MockDefinition & { type?: string } => {\n  if (isReference(schema)) {\n    const {\n      originalName,\n      specKey = context.specKey,\n      refPaths,\n    } = getRefInfo(schema.$ref, context);\n\n    const schemaRef = Array.isArray(refPaths)\n      ? (refPaths.reduce(\n          (obj, key) =>\n            obj && typeof obj === 'object'\n              ? (obj as Record<string, any>)[key]\n              : undefined,\n          context.specs[specKey],\n        ) as Partial<SchemaObject>)\n      : undefined;\n\n    const newSchema = {\n      ...schemaRef,\n      name: pascal(originalName),\n      path: schema.path,\n      isRef: true,\n      required: [...(schemaRef?.required ?? []), ...(schema?.required ?? [])],\n    };\n\n    const newSeparator = newSchema.allOf\n      ? 'allOf'\n      : newSchema.oneOf\n        ? 'oneOf'\n        : 'anyOf';\n\n    const scalar = getMockScalar({\n      item: newSchema,\n      mockOptions,\n      operationId,\n      tags,\n      combine: combine\n        ? {\n            separator:\n              combine.separator === 'anyOf' ? newSeparator : combine.separator,\n            includedProperties:\n              newSeparator === 'allOf' ? [] : combine.includedProperties,\n          }\n        : undefined,\n      context: {\n        ...context,\n        specKey,\n      },\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n      allowOverride,\n    });\n    if (\n      scalar.value &&\n      (newSchema.type === 'object' || newSchema.allOf) &&\n      combine?.separator === 'oneOf'\n    ) {\n      const funcName = `get${pascal(operationId)}Response${pascal(newSchema.name)}Mock`;\n      if (\n        !splitMockImplementations?.some((f) =>\n          f.includes(`export const ${funcName}`),\n        )\n      ) {\n        const discriminatedProperty = newSchema.discriminator?.propertyName;\n\n        let type = `Partial<${newSchema.name}>`;\n        if (discriminatedProperty) {\n          type = `Omit<${type}, '${discriminatedProperty}'>`;\n        }\n\n        const args = `${overrideVarName}: ${type} = {}`;\n        const func = `export const ${funcName} = (${args}): ${newSchema.name} => ({${scalar.value.startsWith('...') ? '' : '...'}${scalar.value}, ...${overrideVarName}});`;\n        splitMockImplementations?.push(func);\n      }\n\n      scalar.value = newSchema.nullable\n        ? `${funcName}()`\n        : `{...${funcName}()}`;\n\n      scalar.imports.push({\n        name: newSchema.name,\n        specKey: isRootKey(specKey, context.target) ? undefined : specKey,\n      });\n    }\n\n    return {\n      ...scalar,\n      type: getType(newSchema),\n    };\n  }\n\n  const scalar = getMockScalar({\n    item: schema,\n    mockOptions,\n    operationId,\n    tags,\n    combine,\n    context,\n    imports,\n    existingReferencedProperties,\n    splitMockImplementations,\n    allowOverride,\n  });\n  return {\n    ...scalar,\n    type: getType(schema),\n  };\n};\n\nconst getType = (schema: MockSchemaObject) => {\n  return (\n    (schema.type as string | undefined) ??\n    (schema.properties ? 'object' : schema.items ? 'array' : undefined)\n  );\n};\n","import {\n  type ContextSpecs,\n  type GeneratorImport,\n  isReference,\n  isSchema,\n  type MockOptions,\n  pascal,\n} from '@orval/core';\n\nimport type { MockDefinition, MockSchemaObject } from '../../types';\nimport { resolveMockValue } from '../resolvers';\n\nexport const combineSchemasMock = ({\n  item,\n  separator,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n}: {\n  item: MockSchemaObject;\n  separator: 'allOf' | 'oneOf' | 'anyOf';\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n}): MockDefinition => {\n  const combineImports: GeneratorImport[] = [];\n  const includedProperties: string[] = [...(combine?.includedProperties ?? [])];\n\n  const isRefAndNotExisting =\n    isReference(item) && !existingReferencedProperties.includes(item.name);\n\n  const itemResolvedValue =\n    isRefAndNotExisting || item.properties\n      ? resolveMockValue({\n          schema: Object.fromEntries(\n            Object.entries(item).filter(([key]) => key !== separator),\n          ) as MockSchemaObject,\n          combine: {\n            separator: 'allOf',\n            includedProperties: [],\n          },\n          mockOptions,\n          operationId,\n          tags,\n          context,\n          imports,\n          existingReferencedProperties,\n          splitMockImplementations,\n        })\n      : undefined;\n\n  includedProperties.push(...(itemResolvedValue?.includedProperties ?? []));\n  combineImports.push(...(itemResolvedValue?.imports ?? []));\n  let containsOnlyPrimitiveValues = true;\n\n  const value = (item[separator] ?? []).reduce(\n    (acc, val, _, arr) => {\n      if (\n        '$ref' in val &&\n        existingReferencedProperties.includes(\n          pascal(val.$ref.split('/').pop()!),\n        )\n      ) {\n        if (arr.length === 1) {\n          return 'undefined';\n        }\n\n        return acc;\n      }\n\n      // the required fields in this schema need to be considered\n      // in the sub schema under the allOf key\n      if (separator === 'allOf' && item.required) {\n        val =\n          isSchema(val) && val.required\n            ? { ...val, required: [...item.required, ...val.required] }\n            : { ...val, required: item.required };\n      }\n\n      const resolvedValue = resolveMockValue({\n        schema: {\n          ...val,\n          name: item.name,\n          path: item.path ? item.path : '#',\n        },\n        combine: {\n          separator,\n          includedProperties:\n            separator === 'oneOf'\n              ? (itemResolvedValue?.includedProperties ?? [])\n              : includedProperties,\n        },\n        mockOptions,\n        operationId,\n        tags,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n      });\n\n      combineImports.push(...resolvedValue.imports);\n      includedProperties.push(...(resolvedValue.includedProperties ?? []));\n\n      if (resolvedValue.value === '{}') {\n        containsOnlyPrimitiveValues = false;\n        return acc;\n      }\n      if (separator === 'allOf') {\n        if (resolvedValue.value.startsWith('{') || !resolvedValue.type) {\n          containsOnlyPrimitiveValues = false;\n          return `${acc}...${resolvedValue.value},`;\n        } else if (resolvedValue.type === 'object') {\n          containsOnlyPrimitiveValues = false;\n          return resolvedValue.value.startsWith('faker')\n            ? `${acc}...${resolvedValue.value},`\n            : `${acc}...{${resolvedValue.value}},`;\n        }\n      }\n      return `${acc}${resolvedValue.value},`;\n    },\n    separator === 'allOf' ? '' : 'faker.helpers.arrayElement([',\n  );\n  let finalValue =\n    value === 'undefined'\n      ? value\n      : `${separator === 'allOf' && !containsOnlyPrimitiveValues ? '{' : ''}${value}${separator === 'allOf' ? (containsOnlyPrimitiveValues ? '' : '}') : '])'}`;\n  if (itemResolvedValue) {\n    finalValue = finalValue.startsWith('...')\n      ? `...{${finalValue}, ${itemResolvedValue.value}}`\n      : `{...${finalValue}, ${itemResolvedValue.value}}`;\n  }\n  if (finalValue.endsWith(',')) {\n    finalValue = finalValue.slice(0, Math.max(0, finalValue.length - 1));\n  }\n\n  return {\n    value: finalValue,\n    imports: combineImports,\n    name: item.name,\n    includedProperties,\n  };\n};\n","import { camel, sanitize } from '@orval/core';\n\nconst hasParam = (path: string): boolean => /[^{]*{[\\w*_-]*}.*/.test(path);\n\nconst getRoutePath = (path: string): string => {\n  const matches = /([^{]*){?([\\w*_-]*)}?(.*)/.exec(path);\n  if (!matches?.length) return path; // impossible due to regexp grouping here, but for TS\n\n  const prev = matches[1];\n  const param = sanitize(camel(matches[2]), {\n    es5keyword: true,\n    underscore: true,\n    dash: true,\n    dot: true,\n  });\n  const next = hasParam(matches[3]) ? getRoutePath(matches[3]) : matches[3];\n\n  return hasParam(path) ? `${prev}:${param}${next}` : `${prev}${param}${next}`;\n};\n\nexport const getRouteMSW = (route: string, baseUrl = '*') => {\n  route = route.replaceAll(':', '\\\\\\:');\n  const splittedRoute = route.split('/');\n\n  return splittedRoute.reduce((acc, path, i) => {\n    if (!path && !i) {\n      return acc;\n    }\n\n    if (!path.includes('{')) {\n      return `${acc}/${path}`;\n    }\n\n    return `${acc}/${getRoutePath(path)}`;\n  }, baseUrl);\n};\n","import {\n  ContextSpecs,\n  generalJSTypesWithArray,\n  GeneratorImport,\n  GlobalMockOptions,\n  isFunction,\n  MockOptions,\n  NormalizedOverrideOutput,\n  resolveRef,\n  ResReqTypesValue,\n  stringify,\n} from '@orval/core';\nimport { OpenAPIObject, SchemaObject } from 'openapi3-ts/oas30';\n\nimport { getMockScalar } from '../faker/getters';\n\nconst getMockPropertiesWithoutFunc = (properties: any, spec: OpenAPIObject) =>\n  Object.entries(isFunction(properties) ? properties(spec) : properties).reduce<\n    Record<string, string>\n  >((acc, [key, value]) => {\n    const implementation = isFunction(value)\n      ? `(${value})()`\n      : stringify(value as string)!;\n\n    acc[key] = implementation?.replaceAll(\n      /import_faker\\.defaults|import_faker\\.faker|_faker\\.faker/g,\n      'faker',\n    );\n    return acc;\n  }, {});\n\nconst getMockWithoutFunc = (\n  spec: OpenAPIObject,\n  override?: NormalizedOverrideOutput,\n): MockOptions => ({\n  arrayMin: override?.mock?.arrayMin,\n  arrayMax: override?.mock?.arrayMax,\n  stringMin: override?.mock?.stringMin,\n  stringMax: override?.mock?.stringMax,\n  numberMin: override?.mock?.numberMin,\n  numberMax: override?.mock?.numberMax,\n  required: override?.mock?.required,\n  fractionDigits: override?.mock?.fractionDigits,\n  ...(override?.mock?.properties\n    ? {\n        properties: getMockPropertiesWithoutFunc(\n          override.mock.properties,\n          spec,\n        ),\n      }\n    : {}),\n  ...(override?.mock?.format\n    ? {\n        format: getMockPropertiesWithoutFunc(override.mock.format, spec),\n      }\n    : {}),\n  ...(override?.operations\n    ? {\n        operations: Object.entries(override.operations).reduce<\n          Exclude<MockOptions['operations'], undefined>\n        >((acc, [key, value]) => {\n          if (value.mock?.properties) {\n            acc[key] = {\n              properties: getMockPropertiesWithoutFunc(\n                value.mock.properties,\n                spec,\n              ),\n            };\n          }\n\n          return acc;\n        }, {}),\n      }\n    : {}),\n  ...(override?.tags\n    ? {\n        tags: Object.entries(override.tags).reduce<\n          Exclude<MockOptions['tags'], undefined>\n        >((acc, [key, value]) => {\n          if (value.mock?.properties) {\n            acc[key] = {\n              properties: getMockPropertiesWithoutFunc(\n                value.mock.properties,\n                spec,\n              ),\n            };\n          }\n\n          return acc;\n        }, {}),\n      }\n    : {}),\n});\n\nconst getMockScalarJsTypes = (\n  definition: string,\n  mockOptionsWithoutFunc: Record<string, unknown>,\n) => {\n  const isArray = definition.endsWith('[]');\n  const type = isArray ? definition.slice(0, -2) : definition;\n\n  switch (type) {\n    case 'number': {\n      return isArray\n        ? `Array.from({length: faker.number.int({` +\n            `min: ${mockOptionsWithoutFunc.arrayMin}, ` +\n            `max: ${mockOptionsWithoutFunc.arrayMax}}` +\n            `)}, () => faker.number.int())`\n        : 'faker.number.int()';\n    }\n    case 'string': {\n      return isArray\n        ? `Array.from({length: faker.number.int({` +\n            `min: ${mockOptionsWithoutFunc?.arrayMin},` +\n            `max: ${mockOptionsWithoutFunc?.arrayMax}}` +\n            `)}, () => faker.word.sample())`\n        : 'faker.word.sample()';\n    }\n    default: {\n      return 'undefined';\n    }\n  }\n};\n\nexport const getResponsesMockDefinition = ({\n  operationId,\n  tags,\n  returnType,\n  responses,\n  imports: responseImports,\n  mockOptionsWithoutFunc,\n  transformer,\n  context,\n  mockOptions,\n  splitMockImplementations,\n}: {\n  operationId: string;\n  tags: string[];\n  returnType: string;\n  responses: ResReqTypesValue[];\n  imports: GeneratorImport[];\n  mockOptionsWithoutFunc: Record<string, unknown>;\n  transformer?: (value: unknown, definition: string) => string;\n  context: ContextSpecs;\n  mockOptions?: GlobalMockOptions;\n  splitMockImplementations: string[];\n}) => {\n  return responses.reduce(\n    (\n      acc,\n      { value: definition, originalSchema, example, examples, imports, isRef },\n    ) => {\n      if (\n        context.output.override?.mock?.useExamples ||\n        mockOptions?.useExamples\n      ) {\n        let exampleValue =\n          example ||\n          originalSchema?.example ||\n          Object.values(examples || {})[0] ||\n          originalSchema?.examples?.[0];\n        exampleValue = exampleValue?.value ?? exampleValue;\n        if (exampleValue) {\n          acc.definitions.push(\n            transformer\n              ? transformer(exampleValue, returnType)\n              : JSON.stringify(exampleValue),\n          );\n          return acc;\n        }\n      }\n      if (!definition || generalJSTypesWithArray.includes(definition)) {\n        const value = getMockScalarJsTypes(definition, mockOptionsWithoutFunc);\n\n        acc.definitions.push(\n          transformer ? transformer(value, returnType) : value,\n        );\n\n        return acc;\n      }\n\n      if (!originalSchema) {\n        return acc;\n      }\n\n      const resolvedRef = resolveRef<SchemaObject>(originalSchema, context);\n\n      const scalar = getMockScalar({\n        item: {\n          name: definition,\n          ...resolvedRef.schema,\n        },\n        imports,\n        mockOptions: mockOptionsWithoutFunc,\n        operationId,\n        tags,\n        context: isRef\n          ? {\n              ...context,\n              specKey: responseImports[0]?.specKey ?? context.specKey,\n            }\n          : context,\n        existingReferencedProperties: [],\n        splitMockImplementations,\n        allowOverride: true,\n      });\n\n      acc.imports.push(...scalar.imports);\n      acc.definitions.push(\n        transformer\n          ? transformer(scalar.value, returnType)\n          : scalar.value.toString(),\n      );\n\n      return acc;\n    },\n    {\n      definitions: [] as string[],\n      imports: [] as GeneratorImport[],\n    },\n  );\n};\n\nexport const getMockDefinition = ({\n  operationId,\n  tags,\n  returnType,\n  responses,\n  imports: responseImports,\n  override,\n  transformer,\n  context,\n  mockOptions,\n  splitMockImplementations,\n}: {\n  operationId: string;\n  tags: string[];\n  returnType: string;\n  responses: ResReqTypesValue[];\n  imports: GeneratorImport[];\n  override: NormalizedOverrideOutput;\n  transformer?: (value: unknown, definition: string) => string;\n  context: ContextSpecs;\n  mockOptions?: GlobalMockOptions;\n  splitMockImplementations: string[];\n}) => {\n  const mockOptionsWithoutFunc = getMockWithoutFunc(\n    context.specs[context.specKey],\n    override,\n  );\n\n  const { definitions, imports } = getResponsesMockDefinition({\n    operationId,\n    tags,\n    returnType,\n    responses,\n    imports: responseImports,\n    mockOptionsWithoutFunc,\n    transformer,\n    context,\n    mockOptions,\n    splitMockImplementations,\n  });\n\n  return {\n    definition: '[' + definitions.join(', ') + ']',\n    definitions,\n    imports,\n  };\n};\n\nexport const getMockOptionsDataOverride = (\n  operationTags: string[],\n  operationId: string,\n  override: NormalizedOverrideOutput,\n) => {\n  const responseOverride =\n    override?.operations?.[operationId]?.mock?.data ||\n    operationTags\n      .map((operationTag) => override?.tags?.[operationTag]?.mock?.data)\n      .find((e) => e !== undefined);\n  const implementation = isFunction(responseOverride)\n    ? `(${responseOverride})()`\n    : stringify(responseOverride);\n\n  return implementation?.replaceAll(\n    /import_faker\\.defaults|import_faker\\.faker|_faker\\.faker/g,\n    'faker',\n  );\n};\n","import {\n  ClientMockGeneratorBuilder,\n  generateDependencyImports,\n  GenerateMockImports,\n  GeneratorDependency,\n  GeneratorImport,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  GlobalMockOptions,\n  isFunction,\n  isObject,\n  pascal,\n  ResReqTypesValue,\n} from '@orval/core';\n\nimport { getDelay } from '../delay';\nimport { getRouteMSW, overrideVarName } from '../faker/getters';\nimport { getMockDefinition, getMockOptionsDataOverride } from './mocks';\n\nconst getMSWDependencies = (\n  options?: GlobalMockOptions,\n): GeneratorDependency[] => {\n  const hasDelay = options?.delay !== false;\n  const locale = options?.locale;\n\n  const exports = [\n    { name: 'http', values: true },\n    { name: 'HttpResponse', values: true },\n    { name: 'RequestHandlerOptions', values: false },\n  ];\n\n  if (hasDelay) {\n    exports.push({ name: 'delay', values: true });\n  }\n\n  return [\n    { exports, dependency: 'msw' },\n    {\n      exports: [{ name: 'faker', values: true }],\n      dependency: locale\n        ? `@faker-js/faker/locale/${locale}`\n        : '@faker-js/faker',\n    },\n  ];\n};\n\nexport const generateMSWImports: GenerateMockImports = ({\n  implementation,\n  imports,\n  specsName,\n  hasSchemaDir,\n  isAllowSyntheticDefaultImports,\n  options,\n}) => {\n  return generateDependencyImports(\n    implementation,\n    [...getMSWDependencies(options), ...imports],\n    specsName,\n    hasSchemaDir,\n    isAllowSyntheticDefaultImports,\n  );\n};\n\nconst generateDefinition = (\n  name: string,\n  route: string,\n  getResponseMockFunctionNameBase: string,\n  handlerNameBase: string,\n  { operationId, response, verb, tags }: GeneratorVerbOptions,\n  { override, context, mock }: GeneratorOptions,\n  returnType: string,\n  status: string,\n  responseImports: GeneratorImport[],\n  responses: ResReqTypesValue[],\n  contentTypes: string[],\n  splitMockImplementations: string[],\n) => {\n  const oldSplitMockImplementations = [...splitMockImplementations];\n  const { definitions, definition, imports } = getMockDefinition({\n    operationId,\n    tags,\n    returnType,\n    responses,\n    imports: responseImports,\n    override,\n    context,\n    mockOptions: isFunction(mock) ? undefined : mock,\n    splitMockImplementations,\n  });\n\n  const mockData = getMockOptionsDataOverride(tags, operationId, override);\n\n  let value = '';\n\n  if (mockData) {\n    value = mockData;\n  } else if (definitions.length > 1) {\n    value = `faker.helpers.arrayElement(${definition})`;\n  } else if (definitions[0]) {\n    value = definitions[0];\n  }\n\n  const isResponseOverridable = value.includes(overrideVarName);\n  const isTextPlain = contentTypes.includes('text/plain');\n  const isReturnHttpResponse = value && value !== 'undefined';\n\n  const getResponseMockFunctionName = `${getResponseMockFunctionNameBase}${pascal(\n    name,\n  )}`;\n  const handlerName = `${handlerNameBase}${pascal(name)}`;\n\n  const addedSplitMockImplementations = splitMockImplementations.slice(\n    oldSplitMockImplementations.length,\n  );\n  splitMockImplementations.push(...addedSplitMockImplementations);\n  const mockImplementations =\n    addedSplitMockImplementations.length > 0\n      ? `${addedSplitMockImplementations.join('\\n\\n')}\\n\\n`\n      : '';\n\n  const mockImplementation = isReturnHttpResponse\n    ? `${mockImplementations}export const ${getResponseMockFunctionName} = (${\n        isResponseOverridable\n          ? `overrideResponse: Partial< ${returnType} > = {}`\n          : ''\n      })${mockData ? '' : `: ${returnType}`} => (${value})\\n\\n`\n    : mockImplementations;\n\n  const delay = getDelay(override, isFunction(mock) ? undefined : mock);\n  const infoParam = 'info';\n  const overrideResponse = `overrideResponse !== undefined\n    ? (typeof overrideResponse === \"function\" ? await overrideResponse(${infoParam}) : overrideResponse)\n    : ${getResponseMockFunctionName}()`;\n  const handlerImplementation = `\nexport const ${handlerName} = (overrideResponse?: ${returnType} | ((${infoParam}: Parameters<Parameters<typeof http.${verb}>[1]>[0]) => Promise<${returnType}> | ${returnType}), options?: RequestHandlerOptions) => {\n  return http.${verb}('${route}', async (${infoParam}) => {${\n    delay === false\n      ? ''\n      : `await delay(${isFunction(delay) ? `(${delay})()` : delay});`\n  }\n  ${isReturnHttpResponse ? '' : `if (typeof overrideResponse === 'function') {await overrideResponse(info); }`}\n    return new HttpResponse(${\n      isReturnHttpResponse\n        ? isTextPlain\n          ? overrideResponse\n          : `JSON.stringify(${overrideResponse})`\n        : null\n    },\n      { status: ${status === 'default' ? 200 : status.replace(/XX$/, '00')},\n        ${\n          isReturnHttpResponse\n            ? `headers: { 'Content-Type': ${isTextPlain ? \"'text/plain'\" : \"'application/json'\"} }`\n            : ''\n        }\n      })\n  }, options)\n}\\n`;\n\n  const includeResponseImports = isTextPlain\n    ? imports\n    : [\n        ...imports,\n        ...response.imports.filter((r) => {\n          // Only include imports which are actually used in mock.\n          const reg = new RegExp(`\\\\b${r.name}\\\\b`);\n          return (\n            reg.test(handlerImplementation) || reg.test(mockImplementation)\n          );\n        }),\n      ];\n\n  return {\n    implementation: {\n      function: mockImplementation,\n      handlerName: handlerName,\n      handler: handlerImplementation,\n    },\n    imports: includeResponseImports,\n  };\n};\n\nexport const generateMSW = (\n  generatorVerbOptions: GeneratorVerbOptions,\n  generatorOptions: GeneratorOptions,\n): ClientMockGeneratorBuilder => {\n  const { pathRoute, override, mock } = generatorOptions;\n  const { operationId, response } = generatorVerbOptions;\n\n  const route = getRouteMSW(\n    pathRoute,\n    override?.mock?.baseUrl ?? (isFunction(mock) ? undefined : mock?.baseUrl),\n  );\n\n  const handlerName = `get${pascal(operationId)}MockHandler`;\n  const getResponseMockFunctionName = `get${pascal(operationId)}ResponseMock`;\n\n  const splitMockImplementations: string[] = [];\n\n  const baseDefinition = generateDefinition(\n    '',\n    route,\n    getResponseMockFunctionName,\n    handlerName,\n    generatorVerbOptions,\n    generatorOptions,\n    response.definition.success,\n    response.types.success[0]?.key ?? '200',\n    response.imports,\n    response.types.success,\n    response.contentTypes,\n    splitMockImplementations,\n  );\n\n  const mockImplementations = [baseDefinition.implementation.function];\n  const handlerImplementations = [baseDefinition.implementation.handler];\n  const imports = [...baseDefinition.imports];\n\n  if (\n    generatorOptions.mock &&\n    isObject(generatorOptions.mock) &&\n    generatorOptions.mock.generateEachHttpStatus\n  ) {\n    for (const statusResponse of [\n      ...response.types.success,\n      ...response.types.errors,\n    ]) {\n      const definition = generateDefinition(\n        statusResponse.key,\n        route,\n        getResponseMockFunctionName,\n        handlerName,\n        generatorVerbOptions,\n        generatorOptions,\n        statusResponse.value,\n        statusResponse.key,\n        response.imports,\n        [statusResponse],\n        [statusResponse.contentType],\n        splitMockImplementations,\n      );\n      mockImplementations.push(definition.implementation.function);\n      handlerImplementations.push(definition.implementation.handler);\n      imports.push(...definition.imports);\n    }\n  }\n\n  return {\n    implementation: {\n      function: mockImplementations.join('\\n'),\n      handlerName: handlerName,\n      handler: handlerImplementations.join('\\n'),\n    },\n    imports: imports,\n  };\n};\n","import {\n  GenerateMockImports,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  GlobalMockOptions,\n} from '@orval/core';\n\nimport { generateMSW, generateMSWImports } from './msw';\n\nexport const DEFAULT_MOCK_OPTIONS: GlobalMockOptions = {\n  type: 'msw',\n  useExamples: false,\n};\n\nexport const generateMockImports: GenerateMockImports = (importOptions) => {\n  switch (importOptions.options?.type) {\n    default: {\n      // case 'msw':\n      return generateMSWImports(importOptions);\n    }\n  }\n};\n\nexport const generateMock = (\n  generatorVerbOptions: GeneratorVerbOptions,\n  generatorOptions: Omit<GeneratorOptions, 'mock'> & {\n    mock: GlobalMockOptions;\n  },\n) => {\n  switch (generatorOptions.mock.type) {\n    default: {\n      // case 'msw':\n      return generateMSW(generatorVerbOptions, generatorOptions);\n    }\n  }\n};\n"],"mappings":"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"}